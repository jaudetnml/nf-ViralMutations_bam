params {
    //Mandatory inputs
    input               = "${launchDir}/samplesheet.csv"
    //Sample sheet containing two (nanopore) or three (Illumina) columns: SampleName,File1,File2
    //For MinION, the File1 field can point to a fastq file with all reads or the folder that contains files to combine
    outdir              = "${launchDir}/Results"
    //Folder where to put the results
    Seq_Tech            = "Illumina"
    //or "MinION"
    Target_Reference    = ""
    //Fasta file containing the reference to align to, just the fasta file name
    SLURM_Queue         = ""
    //When using SLURM, the name of the queue or partition to use

    //snpEff inputs
    SnpEff_Name         = ""
    //name to use when building the snpEff database
    SnpEff_Folder       = ""
    //folder which contains a folder called {SnpEff_Name} containing two files:
    // sequence.fasta: the fasta sequence (same name {>SeqName} as in Target_Reference)
    // genes.gbk: GenBank format file of features
    // For segmented genomes, the GenBank file can be concatenated from the individual segment gbk files.

    //Read filtering
    Read_MinMAPQ        = 30
    // Minimum mapping quality, BWA default is 30
    
    //Consensus calling
    Consensus_MinDepth  = 30
    //Minimum depth to call the consensus for
    Consensus_MinFreq   = 0.7
    //Minimum frequency of an allele to make consensus

    //SNP calling
    SNP_MaxCov          = -1
    //Set to a positive number to downsample over-sequenced areas (set to the maximum depth desired)
    SNP_MinDepth        = 30
    //Minimum depth for a SNP to be reported in filtered output
    SNP_MinFreq         = 0.05
    //Minimum frequency for a SNP to be reported in filtered output
    GenePos             = ""

    tracedir            = "${params.outdir}/pipeline_info"
    max_memory          = '200.GB'
    max_cpus            = 30
    max_time            = '240.h'
}

includeConfig 'configs/profiles.config'
includeConfig 'configs/base.config'

plugins {
    id 'nf-validation@1.1.3'
    id 'nf-iridanext@0.2.0'
    id 'nf-prov@1.2.4'
}

prov {
    enabled = true
    formats {
        legacy {
            file      = "${params.outdir}/manifest.json"
            overwrite = true
        }
        bco {
            file      = "${params.outdir}/bco.json"
            overwrite = true
        }
    }
}

env {
    PYTHONNOUSERSITE = 1
    R_PROFILE_USER   = "/.Rprofile"
    R_ENVIRON_USER   = "/.Renviron"
    JULIA_DEPOT_PATH = "/usr/local/share/julia"
}

def trace_timestamp = new java.util.Date().format( 'yyyy-MM-dd_HH-mm-ss')
timeline {
    enabled = true
    file    = "${params.tracedir}/execution_timeline_${trace_timestamp}.html"
}
report {
    enabled = true
    file    = "${params.tracedir}/execution_report_${trace_timestamp}.html"
}
trace {
    enabled = true
    fields = "task_id,hash,process,tag,name,status,script,scratch,env,container,hostname,duration,realtime,%cpu,rss,vmem,rchar,wchar"
    file    = "${params.tracedir}/execution_trace_${trace_timestamp}.txt"
}
dag {
    enabled = true
    file    = "${params.tracedir}/pipeline_dag_${trace_timestamp}.html"
}

manifest {
    name            = 'phac-nml/nf-ViralMutations'
    author          = """Jonathan Audet"""
    homePage        = 'https://github.com/phac-nml/nf-ViralMutations'
    description     = """nf-ViralMutations"""
    mainScript      = 'main.nf'
    nextflowVersion = '!>=23.04.0'
    version         = '1.1.0'
    defaultBranch   = 'main'
    doi             = ''
}

def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min( obj, params.max_cpus as int )
        } catch (all) {
            println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
            return obj
        }
    }
}